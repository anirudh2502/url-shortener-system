from flask import Flask, request, redirect, jsonify
from datetime import datetime, timedelta
import mysql.connector
import random
import string
import time
import logging
from logging.handlers import RotatingFileHandler                     #a logging handler that manages log files by automatically rotating them when they reach a specified size limit
from prometheus_flask_exporter import PrometheusMetrics              #automatically track HTTP request metrics such as count, latency, and error rates
from prometheus_client import Counter

app = Flask(__name__)

metrics = PrometheusMetrics(app)

#CREATING LOG DIRECTORIES
import os
if not os.path.exists('logs'):
    os.makedirs('logs')

#CONFIGURE  LOGGING 
logging.basicConfig (                                                #configures the basic settings for the root logger in Python
    level = logging.INFO,                                             #sets the minimum severity level of logs that will be captured
    format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'      
)
#%(asctime)s: The timestamp when the log entry is created 
#%(levelname)s: The severity level of the log message (e.g., INFO, ERROR)
#%(name)s: The name of the logger that recorded the message (often the module or class name)
#%(message)s: The actual log message content


#FILE HANDLER WITH ROTATION (MAX 10MB)
file_handler = RotatingFileHandler (              #Log rotation means the current log file is closed and renamed (e.g., url_shortener.log.1)
    'logs/url_shortener.log',
    maxBytes = 10485760,                          #when the log file reaches about 10 megabytes in size, it should be "rotated"
    backupCount = 10                              #keeps up to 10 backup log files. When this number is exceeded, the oldest log file is deleted
)
file_handler.setFormatter(logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
))


#CONSOLE HANDLER                                   enables you to see logs in real-time as your application runs
console_handler = logging.StreamHandler()                       #creates the handler that sends logs to the console
console_handler.setFormatter(logging.Formatter(                       #format for how each log message appears on the console
    '%(asctime)s - %(levelname)s - %(message)s'
))


#ADDING HANDLERS                           components responsible for directing the log messages generated by loggers to specific destinations   
app.logger.addHandler(file_handler)                   # to write log messages into a rotating log file
app.logger.addHandler(console_handler)                #to output log messages to the console for real-time viewing
app.logger.setLevel(logging.INFO)                     

#----------------------------------------#
#METRICS SETUP

urls_created_counter = Counter('urls_created_total', 'Total number of URLs created')
redirect_counter = Counter('redirects_total', 'Total number of redirects')
expired_urls_counter = Counter('expired_urls_total', 'Total number of expired URL access')
notfound_counter = Counter('url_notfound_total', 'Total number of URLs not found')

#DATABASE CONNECTION
def get_db_connection():
    connection = mysql.connector.connect(
        host='localhost',
        user='root',
        password='your_password_here',           #update with your mysql password
        database='url_shortener'
    )
    return connection



def generate_shortcode(length=8):
    characters = string.ascii_letters + string.digits
    short_code = ''.join(random.choices(characters, k=length))            # k is an argument to pick no.of characters from the sequence of given url
    return short_code



def short_url(long_url, expires_in_days=None):
    start_time = time.time()
    try:                                      #try - to catch and handle potential database connection errors
        connection = get_db_connection()
        cursor = connection.cursor(dictionary=True)        
    
        #to check if the url already exists
        cursor.execute("SELECT short_code FROM urls WHERE original_url = %s", (long_url,))
        existing = cursor.fetchone()
        if existing:
            app.logger.info(f"URL already exists: {long_url} -> {existing['short_code']}")
            cursor.close()
            connection.close()
            return existing['short_code']
    
        short_code = generate_shortcode()
    
        cursor.execute("SELECT short_code FROM urls WHERE short_code = %s", (short_code,))
        while cursor.fetchone():
            short_code = generate_shortcode()
            cursor.execute("SELECT short_code FROM urls WHERE short_code = %s", (short_code,))

        expires_at = None                 #url doesn't expire by default unless specified later 
        if expires_in_days:
            expires_at = datetime.now() + timedelta(days=int(expires_in_days))
            app.logger.info (f"URL will expire on: {expires_at}")
        cursor.execute("INSERT INTO urls (short_code, original_url, expires_at) VALUES (%s, %s, %s)", (short_code, long_url, expires_at))
        connection.commit()
        cursor.close()
        connection.close()

        urls_created_counter.inc()              #.inc - to increase the count by one
        duration = time.time() - start_time        #duration - how long a specific operation took to execute
        app.logger.info(f"Created short URL: {short_code} for {long_url} (took {duration:.3f}s)")
        return short_code
    
    except Exception as e:                                                          #this block catches any error while creating a short url, logs it and throws an error in string form                               
        app.logger.info(f"ERROR CREATING SHORT URL: {str(e)}", exc_info=True)
        raise



@app.route('/shorten', methods=['POST'])      #sending input to the server
def shorten():
    start_time = time.time()
    try:
        user_input = request.form['url']           #get the data from the input field that has the name 'url'
        expires_in_days = request.form.get('expires_in_days', None)

        client_ip = request.remote_addr
        app.logger.info(f"URL shorten request from {client_ip}: {user_input}, expires in = {expires_in_days}")
    
        short_code = short_url(user_input, expires_in_days)              #calls the existing short_url function along with input URL
        duration = time.time() - start_time
        app.logger.info(f"Request completed in: {duration:.3f}s")
        
        return jsonify({
        'short_code':short_code,
        'short_url':f'http://localhost:5001/{short_code}',
        'original_url':user_input,
        'expires_in_days':expires_in_days,
        'latency_ms':round(duration*1000, 2)
        })
    except KeyError: 
        app.logger.error("Missing 'url' parameter in request")
        return jsonify ({'error' : 'MISSING URL PARAMETER'}), 400
    except Exception as e:
        app.logger.info(f"Error in shorten endpoint: {str(e)}", exc_info=True)
        return jsonify ({'error' : 'INTERNAL SERVER ERROR'}), 500



@app.route('/<short_code>', methods = ['GET'])                      #dynamic route following whatever the short code is
def redirecting_url(short_code):
    start_time = time.time()
    try:
        connection = get_db_connection()
        cursor = connection.cursor(dictionary=True)

        client_ip = request.remote_addr
        app.logger.info(f"Redirect request from {client_ip} for : {short_code}")

        cursor.execute("SELECT original_url, expires_at FROM urls WHERE short_code = %s", (short_code,))
        url_entry = cursor.fetchone()                   #'url_entry' stores the result obtained from the db query 
        if url_entry:
            if url_entry['expires_at'] is not None:            #if the url has an expiry date given 
                if datetime.now() > url_entry['expires_at']:          #if current time is past the expiry date 
                    expired_urls_counter.inc()
                    app.logger.warning(f"Expired URL accessed: {short_code}")
                    cursor.close()
                    connection.close()
                    return ("THIS URL HAS EXPIRED!!")
                
            redirect_counter.inc()                       #for successful redirects
            duration = time.time() - start_time
            app.logger.info(f"Redirecting {short_code} -> {url_entry['original_url']} (took {duration:.3f}s)")
            cursor.close()
            connection.close()
            return redirect(url_entry['original_url'])
        else:
            notfound_counter.inc()
            app.logger.warning(f"SHORT CODE NOT FOUND: {short_code}")
            cursor.close()
            connection.close()
            return ("URL NOT FOUND!!")
    except Exception as e:
        app.logger.error(f"ERROR IN REDIRECT: {str(e)}", exc_info=True)
        return jsonify("INTERNAL SERVER ERROR"), 500


@app.route('/history')
def history():
    start_time = time.time()
    try:
        connection = get_db_connection()
        cursor = connection.cursor(dictionary=True)

        cursor.execute("SELECT * FROM urls ORDER BY created_at")
        all_urls = cursor.fetchall()          #gets all data/rows from the db query and stores them in this new variable
        cursor.close()
        connection.close()

        duration = time.time() - start_time
        app.logger.info(f"History request returned {len(all_urls)} URLs (took {duration:.3f}s)")
        return jsonify(all_urls)
    except Exception as e:
        app.logger.error(f"Error in history endpoint: {str(e)}", exc_info=True)
        return jsonify({'error' : 'Internal server error'}), 500
    

@app.route('/stats')
def stats():
    try:
        connection = get_db_connection()
        cursor = connection.cursor(dictionary=True)
        #total URLs created
        cursor.execute("SELECT COUNT(*) as total FROM urls")
        total_urls = cursor.fetchone()['total']
        
        #URLs with expiry
        cursor.execute("SELECT COUNT(*) as total FROM urls WHERE expires_at IS NOT NULL")
        urls_with_expiry = cursor.fetchone()['total']

        #expired URLs
        cursor.execute("SELECT COUNT(*) as total FROM urls WHERE expires_at < NOW()")
        expired_urls = cursor.fetchone()['total']

        #active URLS
        cursor.execute("SELECT COUNT(*) as total FROM urls WHERE expires_at IS NULL OR expires_at > NOW()")
        active_urls = cursor.fetchone()['total']

        #recent URLs (last 24hrs)
        cursor.execute("SELECT COUNT(*) as total FROM urls WHERE created_at > NOW() - INTERVAL 1 DAY")
        recent_urls = cursor.fetchone()['total']

        cursor.close()
        connection.close()
        app.logger.info("Stats endpoint accessed")          #stats endpoint - a specific url that provides data/metrics about performance, storage, etc.

        return jsonify({
            'total_urls_created' : total_urls,
            'urls_with_expiry' : urls_with_expiry,
            'expired_urls' : expired_urls,
            'active_urls' : active_urls,
            'urls_created_last24' : recent_urls
        })
    except Exception as e:
        app.logger.error(f"Error in stats endpoint: {str(e)}", exc_info=True)
        return jsonify({'error' : 'Internal server error'}), 500

if __name__ == '__main__':
    app.logger.info("STARTING URL SHORTENER APPLICATION...")
    app.run(debug=True, port=5001)
